<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Berners-Lee!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>C++</title>
        <para>
C++: Benedek Zoltán, Levendovszky Tihamér Szoftverfejlesztés C++ nyelven
	</para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
	<para>
Nem szeretnék túl sok bevezetéssel kezdeni, hiszen ennek a könyvnek egy részéről már írtam a prog1-es részben, illetve a következő Java olvasónaplóban is vannak részek, ahol kiemelem a Java és a C++ különbségeit röviden, de külön is le szeretném írni, itt az általánosság mellett inkább C++-ra kihegyezve a történetet.
A C++ egy objektumorientált nyelv, amelynek kialakulásához az egyre bonyolultabb programok igénye vezetett. Itt az áttekinthetőség és a hatékonyság volt a legfontosabb. Az osztály lényegében egy egységbe záró adatstruktúraként fogalmazható meg. Az osztály példányokkal, vagy más néven egyedekkel rendelkezik, ezeket nevezzük objektumoknak. Az osztály egyik feladata az adatrejtés, amelyet az objektumokkal kehet megvalósítani. Célja, hogy (például) csak azok az osztályok férjenek hozzá, amelyek dolgoznak az adattal, de más ne férjen hozzá, így ne legyen akárhagyon kinyerhető egy adat. Az öröklődés során egy osztály objektumai "öröklik" és másik, általánosított osztály tulajdonságait. A C++ OO, tehát objektumorientált nyelv. Emiatt létezik benne típustámogatás, tehát a programozó, vagy felhasználó által definiált típusok úgy viselkednek mint a beépített típusok. Ez az objektum orientáltság jellemző Javara is. Az egységbe záráskor tagváltozókat (objektumok), vagyis attribútumokat, valamint tagfüggvényeket, vagyis metódusokat hozhatunk létre. C++-ban és Javaban is létezik a "hatókör" fogalma, ha az osztályokból szeretnénk például valamelyik tagfüggvényt használni, mivel lehetnek különböző osztályokban azonos nevű és paraméterlistájú tagfüggvények. Ennek a megkülönböztetésére szolgál. A Javaban történő használatról írtam a következő olvasónaplóban. C++-ban viszont ebben az esetben a hatókör, azaz scope operátort használjuk, amelyet :: (dupla kettősponttal) jelölünk. Itt vissza térnék még egy kicsit az adatrejtésre (data hiding). A lényegéről írtam, de a megvalósításáról is szeretnék egy kicsit. Az osztályokon és struktúrákon belül  kulcsszóval tudjuk befolyásolni, hogy az adatot használhatja bármi más ami az osztályon kívül van. (Igazából 3, mert ott van a protected is, de azt későbbre hagynám még.) Ez a 2 pedig a private és public. A private és public egymás ellentétei. Még előbbi azt éri el, hogy az adott tagváltozók és tagfüggvények csak az adott osztályon belül legyenek elérhetőek, addig az utóbbi pont az ellenkezőjét, tehát ezek az osztályon kívül és belül is láthatóak lesznek. A C++-ban szintén jelen van a dinamikus memóriakezelés, de itt már nem függvény (mint C-ben), hanem operátor felelős érte. A new operátor szolgál a memóriafoglalásra, és a new a lefoglalt típusra mutató pointerrel tér vissza. A lefoglalt helyet a delete operátorral tudjuk felszabadítani, amennyiben már nincs rá szükségünk. C++-ban nagykülönbség van az értékadás és az inicializálás között. Inicializálásra akkor van szükség, ha változókat vagy objektumokat szeretnénk létrehozni, értékadást viszont az "=" jellel történik, amivel a már meglévő változóknak vagy objektumoknak egy értéket adunk.
	</para>
    </section>        

    <section>
        <title>Java</title>
        <para>
Java: Nyékyné Dr. Gaizler Judit et al. Java 2 útikalauz programozóknak 5.0 I-II.
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
	<para>
A Java nyelv jelölésrendszere nagy hasonlóságot mutat a C++-szal, mivel több mindent átvett a nyelvből. Objektumorientált, valamint az osztálykezelés az alapja. A Java nyelv szintaxisa a C és a C++ nyelv felhasználásával alakult ki. Az utóbbi két nyelvvel ellentétben itt muszáj megjelölni a visszatérési típust. Az appleteknek az internetes felhasználás miatt lett nagy jelentősége, ugyanis ezek a HTML oldalba beágyazva futtathatóak. A változók deklarálása, típusai is hasonlóan történik a 3 említett nyelvben. Javaban szintén jelen vannak az operátorok, pl az = jel, amelynek egy felhasználása pl az értékadás egy változónak. A konstansok, vagyis állandók, illetve a megjegyzések jelölése szintén azonos a nyelvekben. C-ben nincs, de Javaban és C++-ban van osztálykezelés. Javaban a karakterláncok, vagyis a nem csak egy karakterből álló tömb kezelésére új osztályt hoznak létre (string). A new operátorral lehet objektumot létrehozni, ugyanis ez az operátor foglalja le a szükséges méretű helyet, majd inicializálja azt, és innentől kezdve referenciaként használja, azzal tér ide vissza. Egyszerű típusok esetében lehet a new operátor nélkül is inicializálni. Azok az elemek, amelyeket static-kal deklaráltunk, azok az adott osztályhoz tartoznak, nem az objektumhoz. Javában nincs eszközünk ahhoz, hogy megszüntessünk egy objektumot. Amikor Javaban egy metódust szeretnénk alkalmazni, akkor a szerkezetet egy class szóval kell bevezetnünk. A metódusok létrehozásánál is vannak bizonyos szabályok, amelyeket muszáj betartanunk. A kivételkezelés szintén fontos szerepet tölt be a nyelvekben, ugyanis ezek a megbízhatóság növelésére szolgálnak. Például ekkor érdemes használni a try-catch blokkot. Az AWT, vagyis az Abstract Window Toolkit-nek egy felhasználói felület összeállításában, megjelenítésében lehet például szerepe. Lehetőségünk van azonban (ha az AWT-vel nem vagyunk elégedettek) saját grafika írására is. Ha felhasználjuk a párhuzamosítási lehetőségünkét, akkor változó/mozgó képet érhetünk el a használt értékek szabályszerű változtatásával, illetve a metódusokon történő változtatásokkal. A párhuzamosítási szál a thread. A könyvben szereplő példa ezzel a szállal végzi az ábra forgatását. A Swing csomag az AWT-hez hasonlít, de sokkal több választási lehetőséget tartalmaz.
A nyelvek karakterkészlete szintén sok hasonlóságot mutat, ugyanis az ASCII táblázatot használják, illetve a Unicode karaktereket. Javaban a típusok között lényeges különbség van, ugyanis nem mindegy a használat szempontjából, hogy primitív típusú a változó (pl int változó) vagy sem (pl az Intiger típusú objektumhivatkozást tartalmaz). Literálokat kell használnunk, ha egyszerű típusokat vagy objektumokat szeretnénk inicializálni, erre több féle literál szolgál. Amikor változót deklarálunk mindenképp nevet kell adni annak, ez igaz a C++-ra és a Javara is. Értéket adni neki nem muszáj azonnal. Javaban a tömb egy típust jelöl, ebben különbözik a C++-tól, ugyanis nem csak a mutató jelölése másképp, de több dimenziós tömb viszont nem létezik, ha azt szeretnénk, akkor a tömbbe újabb tömböt kell tenni. Léteznek felsorolási típusok, amiket a tömbökhöz tudnék hasonlítani működés szempontjából (indexelés), sorszám szerint tudunk értéket adni ezeknek. Az operátorok szerepe az, hogy megadja a kiértékelés sorrendjét. A Java nyelv erősen típusos, ezért van szükség típuskonverzióra, amely során megvizsgálja, hogy léteznek e összegyeztethető típusok, vagy konverzióval azonos típusra lehet e alakítani a különböző elemeket. Javaban egy struktúra egyik részelemének/tagjának eléréséhez a "." karaktert használhatjuk az elemek közötti elhelyezéssel. Itt nincs megkülönböztetve az osztályok elérése mint C++-ban, ott erre a "::" operátor szolgál.
Az utasításokon belül 2 fajta utasítást tudunk megkülönböztetni. Ezek a kifejezés- és deklaráció-utasítás. Mindkettőt azonosan ; zárja, előbbi értékadásra, postfix vagy prefix képezésre, metódushívásra vagy példányosításra szolgál, még utóbbi egy lokális változó létrehozására/inicializálására. Ha Javaban elágazási szerkezetet szeretnénk készíteni, azt kétféleképpen tehetjük meg, az egyik az egyszerű elégazás, amelyhez egy if-szerkezet szükségez, még a másikhoz, az öszetett elágazáshoz switch-szerkezet szükséges. A Java összesen 4 féle ciklust ismer, amelyekben a vizsgálati helyek változnak. Ezek az elöl-, hátultesztelő ciklusok, a léptető (for/while) és bejáró (for) ciklus. Léteznek utasítások, amelyekkel a program vezérelhető, pl bizonyos körülmények között megállítható, folytatható, vagy az adott ponton átugrik egy másik pontra (utasításra). Ezek a: címkék, break és continue utasítások, a visszatérés és a goto.
A Java alapja az osztálykezelés, a legkisebb önálló egység benne az osztály. Az osztályok egyfajta modellezési szerepet töltenek be, egy rendszert épít fel. Példányok, objektumok és egyedek szerepelnek bennük, bár ezek a kifejezések ugyan azt jelentik, de lényeges tudnunk, hogy melyik osztályban vannak és ezt jelezni valahogyan. Az osztályoknak saját változó készlete van, így akár 2 különböző osztályban is használhatunk azonos változónevet pl. Az osztály egyik szerepe az egységbe zárás, tehát az adatok és műveletek összefogása. Biztonsági funkciója is van, pl adatrejtés. Ha osztály változójára hivatkozunk, akkor a változó neve előtti ponttal elválasztvamegadhatjuk, hogy melyik más objektum változójára hivatkozunk. Ennek akár a metódusok működésében is lehet fontos szerepe. Ezeket a metódusokat metódusdefiníciók írják le, valamint fej és törzs részből áll. A fej előtt a módosítók állnak, a törzs pedig az utasításblokk. Ebben azonos a Java és a C++, hogy a törzs és a fej nincs külön választva. Ha metódushívást alkalmazunk ügyelnünk kell a paraméterlistában megadott dolgokra, ugyanis ezek kötött tényezők a használat során (típusoknak egyezni kell, és a paraméterszámnak). Ha példányra szeretnénk alkalmazni, akkor a metódusnévvel ellátott objektummal kell hívnunk. A metódus zárójelezésére szintén ügyelni kell, ugyanis ha nincs paraméterlista is szükséges a () zárójelezés. Egy metódusnevet többször is használhatunk, csak a paraméterlistájuk ne egyezzen meg (paraméterek száma/típusa), ezt nevezzük metódusnevek túlterhelésének. A helyes használatot utána a Java fordító tudni fogja, a jót választja ki még a lefordítás idejében. Az objektumok a példányosítással hozhatók létre a new operátor használatával. A folyamat közben a new operátor memóriát foglal le, ahol az objektum változóit elhelyezi, és a memória kezdőcímét adja vissza. Az ezzel kapott referenciát a megfelelő osztály típusú változónak adható csak át. Ha már nincs szükségünk egy objektumra, akkor érdemes törölni azt. Itt különbség van a C++ és Java között, ugyanis mint sok nyelvben a C++-ban a programozónak kell törölni azt (így könnyen ütközhet hibába a használat miatt), még a Javaban viszont a program futás közben vizsgálja, és ha már nincs rá szükség akkor törli magától, ez a szemétgyűjtő mechanizmus. Az osztályoknál figyelnünk kell a hozzáférhetőségekre. Erre szolgál pl a private, public vagy protected hozzáférési kategória, tehát a láthatóságra. Ez alapján több csoportra bonthatjuk szét: félnyilvános, nyilvános, privát vagy leszármazottban hozzáférhető tagok. Az osztály szintű tagokat példányváltozóknak nevezzük. Az osztályváltozók és metódusok más néven statikus tagok elé a static módosítót helyezzük. Ezek az osztályokhoz kapcsolódnak. Az osztályváltozók és a példányváltozók inicializálása is az előfordulási sorrend szerint történik, de az előbbi kezdőértéket csak egyszer kap, még utóbbi minden meghíváskor inicializálódok. Ugyan úgy hivatkozunk rájuk. Az osztálymetódus az az osztályon belüli műveletet takarja, ehhez csak az osztályváltozók használhatóak fel. Az osztályokon belül konstruktorokat es destruktorokat használunk. A destruktorok feladata a törlés, amiről nemrég írtam, hogy C++-ban a programozók (röviden és tömören) ennek a segítségével szüntethetnek meg meg. A konstruktor lényegében példányosítás, de a hibalehetőségek száma kisebb. A konstruktordefiníció leginkább a metódusdefinícióhoz hasonlítható. Ha példányosítani szeretnénk, a new operátor számára paraméterek is megadhatóak, ezek a paraméterek azok amelyeket a konstruktornak szeretnénk adni. Öröklődést pedig úgy tudnám jellemezni, hogy egy osztályt egy másik osztállyal bővítünk. Ezután a szülő osztályon keresztül elérhető a gyermek osztály, valamint a gyermek osztály örökli a szülő tulajdonságait a létrehozásakor. A gyermek osztály lényegében a szülőnek a kibővítése. Viszont a szülő megadhatja, hogy egy metódusa például public vagy private. Ami private, azt a gyermek már nem látja (ha public vagy protected, akkor látja a szülő metódusait). Ez igaz a Javára és C++-ra is. Az osztályhierarchiáról, metódustúlterhelésről és hatáskörről korábban már írtam úgy, hogy az mindkét nyelvre igaz legyen, így áttérnék a többire. A polimorfizmusban létezik egy szülő osztály, és azon belül lehet bármennyi gyermek osztály, amelyek öröklik a szülő tulajdonságait. Ha a szülő osztályt példányosítjuk, akkor utána polimorfizmussal a szülőn keresztül elérhetőek a gyermekek. Például a példányosított szülő osztályban létrehozunk egy objektumot, és a szülőn belül vannak (extend), leszármaztatott gyermek osztályok. Ezeket a gyermekeket pedig akár öbbet is bele tölthetünk az említett adott objektumba. Emiatt nevezzük a polimorfizmust más szóval többalakúságnak, vagyis inkább ha lefordítjuk a szót. A polimorfizmus során a gyermekek kaphatnak még azonos metódusokat, de ezeket külön-külön kezelik, hiába azonos a metódus (mintha a két gyereknek ugyanaz a jellemzője lenne más tulajdonságú). Ha absztakt osztályokról és az interfészekről beszélünk, akkor azonnal eszünkbe juthat, hogy vannak absztakt függvények és metódusok is. Ha ezeket szeretnénk használni, akkor a definiálásuk során használhatjuk az abstract vagy public kulcsszót, de ezek nem kötelezőek. Javaban az interfész nem tartozik már az osztályokhoz. Ez lényegében az előbb említett absztakt metódusokat és konstansokat használja. Az interfész lényegében egy felület, és a bennetalálható metódusok csak deklarálva vannak, kifejtve nincsenek. A interfészeken belül is létezik örödlődés, a szülő-gyermek kapcsolat. Az absztrakt és az osztályok metódusai között annyi különbség van a deklarációjukban, hogy az absztraktnak nincs törzse. C++-ban az absztakt osztály pedig tulajdonképpen az interfészben megjelenő műveletek és objektumok felsorolása. Ahogy olvastam a 2 könyvet én úgy vettem észre, hogy a lényege és a főbb összetevők (pl absztakt metódusok) azonosak, a megvalósításukban látok különbséget (szerintem a C++ itt bonyolultabb). Az egységbe zárás pedig a date hiding, vagyis rejtés lényegében, de arról korábban már írtam. A következő fejezetről nem beszélnék sokat, hiszen az egyik feladat lényegében az egészet feldolgozza (14.3). Az alapján írok egy rövid összefoglalót. Tovább mennék, és röviden fogalmaznék. Az első a karakterkészletek. Általában ASCII karakterkészletet használunk, bár létezik néhány ékezetes betű amit nem tartalmaz a készlet (mivel 8 biten tárol). Ha ezt szeretnénk kikerülni, mert szükségünk van azokra is (pl angol nyelvezetnél felesleges), akkor a unicode-ot érdemes használni. Következőként a lexerek jönnének, de ezt nem szeretném itt kirészletezni, mert a l334d1c4 feladat (15.2) tartalmazza a választ. A kifejezésekről és utasításokról pedig írtam az előzőekben, még valahol az olvasónapló eleje körül, ezért nem fejteném ki azt is újra. Ha jól emlékszem korábban erről isvolt már szó, de inkább írom most. Javában léteznek primitív és nem primitív változók. Ami nem primitív, az már lényegében itt osztályként alkalmazható, a primitívnek pedig összesen 8 típusa létezik, ezek: int, long, boolean, float, char, double, short, byte. Tehát így nézne ki a Java típusrendszere. A következő a konstansok. Ez megtalálható Javaban és C++-ban is egyaránt, különbség, hogy C++-ban osztályon kívül is alkalmazható. Amennyiben viszont osztályon belül van, akkor meg kell határoznunk, vagyis inicializálni kell. Ezzel adhatunk a konstansnak egy kezdeti értéket. A nevéből is lehet következtetni, a konstans egy állandó változót jelent lényegében (bár pongyola fogalmazással). Az, hogy osztályon belül hol hoztuk létre mindegy, a program tudni fogja a sorrendet. Használhatunk még operátorokat, ezek pedig akkor jutnak szerephez, ha műveleteket szeretnénk végrehajtani. Léteznek bizonyos esetek, amikor a kívánt cél eléréséhez muszáj túlterhelni az operátorokat. Az indexelőkről nekem először a tömbök jutnak az eszembe, hiszen a [ ] zárójelek között hivatkozhatunk akár egy tömb index számára. Ami itt újdonság lehet (szerintem), az az osztályok és objektumok indexelhetősége, ugyanis erre is van lehetőség, szinten [ ] zárójelek között. Ha jól emlékszem szintén volt már szó a konstruktorokról és destruktorokról, de mivel nem vagyok benne biztos, inkább írom itt is. Mindkettőre az osztályoknál van szükségünk, és bizonyos szabályokat követnek. A konstruktoroknál ezek a bizonyos szabályok megmondják, hogy mik a feladatai, ezek: a konstruktort az osztály elején kell meghívni, és ezzel megadunk egy kezdeti állapotot, ezt nevezzük példányosításnak, amikor az osztály meghívódik. A neve pedig azonos az osztályéval, amiben szerepeltetjük. Lényegében ez erőforrást és memóriát foglal le, ezért kell meghívni a destruktorát, ha már nincs rá szükség. Ezzel megszüntetjük az előbbieket, illetve az objektumokat (aminek pl hely volt foglalva), használata pedig egy hullámvonal (~) amit az adott osztály neve követ. (A rossz használata pl memóriafolyást okozhat.) A beágyazott típusok pedig a beágyazott osztályok lényegében, tehát egy osztályba beültetett/beágyazott másik osztály. Ezt szebben nem tudom megfogalmazni. Térjünk át a következő fontosabb témakörre. Az interfészek majdnem egyenlőek az absztrakt osztályokkal, nincs nagy különbség. A normál osztályokhoz képest viszont különbség, hogy nem tartalmaz tagváltozókat és a metódusok kifejtését, vagyis implementációját sem. Használni pedig az implementáción keresztül lehet. A következő téma a kollekciók. Más néven gyűjtemények. Ezek a legtöbb nyelvben használhatóak. Javaban létezik egy kiindulója, ami az összes többi alapjául szolgál. A feladata az objektumokkal való dolgozás, tehát például a lekérdezésük, és ezeket a típusaik szerint (1/több) elhelyezze a gép memóriájában. Ha meg kellene említeni a leggyakrabban gyakorlatban is felmerülő példát, akkor akkor az a összekapcsolás, vagyis tömbök és objektumok összekapcsolása referencia vagy pointerrel (Java/C++). A funkcionális nyelvek lényegében egyenlőek egy speciális függvénnyel, mivel a programot egy darab függvényként kezeli, amit végül kiértékel. Egyszerű, de a kapott paraméterek alapján ad vissza nekünk egy értéket végeredményként. A lambda kifejezések pedig olyan metódusok, amelyeknek nincs neve, és csak ott szerepeltetjük, ahol aktuálisan szükség van rá, nem kell előre deklarálni, de emiatt csak egyszer felhasználható. Imperatív nyelvekben megtalálható, ami itt minket érdekel az a Java és C++, de a feladatokban lesz példa rá. Akkor jöhet megint a következő témakör. Első az adatfolyamok kezelése és a streamek. C++-ban ezek lényegében a byte sorozatokat fedik. Az iostreamet emiatt szinte mindig meghívjuk, hiszen írás olvasáshoz szükséges. Ez fedi az input és az output streamet. Az írás olvasáshoz pedig erre a két operátorra van szükségünk: <programlisting language="c"><![CDATA[ << és >> ]]></programlisting> . Javaban a különbség, hogy itt ezek is objektumok. Emiatt pedig 3 különböző osztállyal lehet használni ezeket, a felhasználási módok szerint elkülönítve, ezek pedig: adattípusok szerint, az adatfolyam iránya szerint és funkciójuk/feladatuk szerint. Állománykezelésnél a C++ most is adatfolyamokban gondolkozik, emiatt pedig az ifstreamre és az ofstreamre van szükségünk, ezek tehát a be- és a kimeneti adatfolyamok, de létezik egy fstream is, ami kétirányú "forgalmat" biztosít. Javaban ez teljesen más, alapjáraton hasonló implementációt nem is ismer. Ha ilyesmit szeretnénk, akkor egy rendszerfájlt kell használnunk, a random acces filet. Ami előnye viszont, hogy nincs határozott sorrend, bárhonnan ír és olvas, ezt viszont logikus, hogy egy mutatóval végzi, hiszen anélkül nem lehetne bárhonnan írni olvasni. Szerializációnál az adatfolyamokba objektumokat ültethetünk. Ennek során pedig bájtsorozatokat tudunk képezni ezekből. Osztályokat is lehet szerializálni, de akkor szükséges, hogy az tartalmazza a "serilizable interfészt". Viszont ha ez így szerializálható, akkor a gyermeke is. 
	</para>
    </section>        

    <section>
        <title>Python</title>
        <para>
Python: Forstner Bertalan, Ekler Péter, Kelényi Imre: Bevezetés a mobilprogramozásba.
Gyors prototípus-fejlesztés Python és Java nyelven (35-51 oldal)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
	<para>
A Pythont fejlesztők számára alakították ki, általános célú programnyelv, amely magas szintű, dinamikus, objektumorientált és platformfüggetlen. A Python alkalmas összetettebb feladatok illetve problémák megoldására, mert sok csomagot és beépített eljárást is tartalmaz és támogatja a magas szintű típusokat. A C, C++ és Java nyelvekkel ellentétben, itt nincs szükség külön fordításra, az értelmezőnek csak a Python kódot kell megadni a futtatáshoz. Inkább nevezhetjük ezek miatt programozási nyelvnek, mint szkript nyelvnek. A kódkönyvtár rengeteg előre megírt modult tartalmaz, ezzel sok időt spórolva a programozóknak (pl: fájlkezelés, hálózatkezelés, rendszerhívások). A nyelv jellemzője, hogy könnyű vele rövid, de tartalmas, velős kódot írni (gyorsítja pl: magas szintű adattípusokkal rövid összetett kifejezések írása, egyszerűbb a tagolás mint C++-ban vagy Javaban, nincsenek zárójelek és nem szükséges a változók és az argumentumok definiálására). A zárójelek helyett a tagolása behúzásokkal történik meg, annak az egységére viszont figyelni kell. Például egy adott blokk végét egy üres sorral tudjuk jelölni. A Python értelmezője a sorokat ún. tokenekre bontja, amelyek lehetnek azonosítók, kulcsszavak, operátorok, delimiterek vagy literálok. Pythonban is vannak előre lefoglalt kulcsszavak, ezeket a könyv egy táblázatban felsorolja. Itt a típusok ábrázolása is másképp működik, az adatok objektumként tárolódnak, és a műveletek is azoknak a típusától függ. A Python csak számokat (azon belül egész, lebegőpontos vagy komplex), sztringeket, enneseket, listákat és szótárakat ismer adattípusként. Ha sztringeket szeretnénk írni, akkor az " " idézőjelek között tehetjük meg, de a unicode-ot is ismeri. Itt is van NULL érték, de itt None-nak nevezzük, de tökéletesen alkalmazható boolenként. Ha egy gyűjtemény None elemű, akkor True, másképp False. Pythonban objektumokra mutató referenciákat jelentenek a változók, de az értékadásuk szintén "=" jellel történik meg, akárcsak más magas szintű programozási nyelvekben, és ilyen módon vannak jelen a lokális és globális (igaz utóbbinál lényeges, hogy a függvény előtt legyen global kulcsszóval, de működés szempontjából azonos) változók. A szekvenciákon különböző műveleteket is végezhetünk, valamint indexeléssel érhetjük el az elemeit. Ha ":" jelet használunk, akkor azzal a szekvencia számára egy intervallumot tudunk megadni. Pythonban szükségünk van kulcsokra, ha a szótárakról beszélünk, ugyanis annak elemeit a szögletes "[ ]" zárójelekbe beleírt kulcsokkal lehet elérni. Pythonban a print metódus szolgál kiiíratásra (tehát konzolra, stdout), de a tokeneket amiket szeretnénk megjeleníteni vesszővel el kell választani. Az if elágazás és a for ciklus szintén hasonló működésű a többi nyelvhez, bár a for ciklussal itt a kulcsokon is tudunk műveletet végrehajtani, vagy kikeresni egy kulcsot például a hozzá tartozó értékkel együtt. Még 2 függvényt érdemes megemlíteni, a range függvényt (alapesetben a range(x) 0-tól x-ig számol, de intervallum is megadható neki) és az xrange, amely hasonló, de kevesebb memóriát foglal. A while ciklus pedig a feltétel teljesüléséig működik. Léteznek címkék, amelyeket a label kulcsszóval tudunk megadni, és a goto utasítással pedig ahhoz a ponthoz ugorhatunk. Amennyiben magunk szeretnénk egy függvényt definiálni, akkor azt a def kulcsszóval tehetjük meg. Ezeket nézhetjük úgy is, mintha értékek lennének, hiszen továbbadhatóak. Azonban paraméterekkel is elláthatjuk őket, és a paraméterek is átadhatóak, csak (kivétel a mutable típus) érték szerint kell kezelni. Pythonban is van lehetősége a programozóknak objektumorientált fejlesztésre, programozásra. Ennek következménye, hogy használhatunk osztályokat, amelyeknek az objektumok a példányai, attribútumnak pedig az objektumokat vagy függvényeket (tagfüggvény/metódus más néven) nevezzük. Ha egy osztály attribútumát megváltoztatjuk, akkor az az összes többi példány attribútumára hatással lehet, ha csak nem módosítottunk azokon is. A Pythonban sok modul áll a rendelkezésünkre, tehát nem csak a szabványosak, hanem a mobilfejlesztéshez is tartalmaz modulokat (pl mobilhálózat, kamera, stb). Létezik kivételkezelés is, ami viszont különbözik a Javatól és C++-tól. A try kulcsszó után kerül a blokk, majd ezután az except blokk következik, ahova hiba után átkerül az irányítás. Az elágazásokhoz fűznék még annyit, hogy Pythonban létezik az "elif" kulcsszó, ami az else if itteni verziója.
	</para>
    </section>  
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
