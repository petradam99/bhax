<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gutenberg!</title>
        <keywordset>
            <keyword/>
        </keywordset>
        <cover>
            <para>
                Programozás tankönyvek rövid olvasónaplói.
            </para>
        </cover>
    </info>
    <section>
        <title>Programozási alapfogalmak</title>
        <para>         
            <citation>PICI</citation>       
        </para>

	<para>
Ez az olvasónapló a "Pici könyv" előadások alkalmával meghatározott részeit dolgozza fel. Az első fő egység az alapfogalmak. A programozási nyelveknek 3 különböző szintet állapítottak meg, ezek a gépi nyelv, assembly szintű nyelv, és a magas szintű nyelv. A magas szintű nyelvvel foglalkozunk az órákon. A forrásprogram a programozási nyelven megírt programot jelenti, a "nyelvtani" szabályokat fedi le a szintaktika, valamint az értelmezésért és a tartalomért a szemantikai szabályok a felelősek. A fordítóprogramos vagy interpreteres technika felelős a magas szintű forráskódok gépi nyelvre történő fordításáért, és ezzel előállítja a tárgyprogramot, amit különböző sémák mentén elemez, majd legenerálja a kódot. Léteznek fordítóprogramok, amelyek lényegében bármilyen nyelvről fordít át egy másikra. A hivatkozási nyelv a programnyelvek saját szabványa, ahol a szintaktikai és szemantikai szabályok pontosan meg vannak határozva. Az implementációk realizált interpreterek vagy fordítóprogramok. Az implementációk nem kompatibilisek más implementációkkal és hivatkozási nyelvekkel. Ez a hordozhatóság problémája, amit napjainkig nem tudtak megoldani. Manapság már léteznek integrált fejlesztői környezetek (IDE), amelyek nagyban megkönnyítik a programozó dolgát, mivel szinte mindent tartalmaznak, amire szükség lehet. A nyelvek osztályozásában több dolgot ismerünk. Az első az imperatív nyelv, ami algoritmus alapú, és képes értékek közvetlen manipulására. 2 alcsoportja van: eljárásorientált és objektumorientált nyelvek. A deklaratív nyelvek nem algoritmusosak, és beléjük van építve a megoldás keresésének módja. Alcsoportjai a funkcionális és logikai nyelvek. Azok a nyelvek amik ide nem sorolhatóak a máselvű nyelvek közé sorolhatóak.
	</para>
	<para>
A következő amiről írni szeretnék egy kicsit, azok az adattípusok. Az adattípus maga is egy programozási eszköz, amely absztrakt. Az adattípusok név alapján azonosíthatóak. Nem minden programnyelv ismeri ezt, ezért típusos és nem típusos nyelv formájában különböztetjük meg. Az adattípusok a programozási eszközök fölvehető értékeit szabályozza, ide tartoznak a végrehajtható műveletek és minden egyes adattípus mögött áll egy meghatározott, megfelelő ábrázolási mód (pl bájtok és bitkombinációk). A típusos nyelvek rendelkeznek standard, vagyis állandó beépített típusokkal. Léteznek olyan programnyelvek, ahol saját adattípust hozhatunk létre (műveletekkel, mindennel együtt). Két nagy csoportja van az adattípusoknak. Az egyik a skalár vagy egyszerű adattípusok, amelyek atomi értékekkel rendelkeznek, tehát műveletekkel nem bonthatóak tovább. A másik a strukturált vagy összetett adattípus, aminek az elemei már rendelkeznek valamilyen típussal.
	</para>
	<para>
A nevesített konstans egy programozási eszköz, amily 3 részből áll: név, típus és érték. A konstans deklarációjakor megadjuk az értékét, és ezen a program további részében nem lehet módosítani. Praktikus beszélő nevekkel ellátni, amivel biztosan tudni fogjuk, hogy miért vezettük be. Ha egy értéket többször használunk a programon belül érdemes használni, mert így ha változtatni akarunk, elég egy módosítást végezni a deklarációban, nem kell minden előfordulást megkeresni. A változó szintén egy programozási eszköz, amely 4 komponenssel rendelkezik: név, attribútumok, cím és érték. A név azonosítóként szolgál, amellyel azonosíthatjuk a másik 3 komponenst. Az attribútumok a változók futás során történő viselkedését határozzák meg, a változó által felvehető értékek körét határolja be. A deklaráció segítségével tudjuk a változókhoz rendelni, így különböző típusokat tudunk megkülönböztetni: explicit deklaráció, implicit deklaráció és automatikus deklaráció. 
	</para>
	<para>
(alapelemek az egyes nyelvekben) A C nyelv típusrendszere aritmetikai (egész, karakter, felsorolásos, valós), származtatott(tömb, függvény, mutató, struktúra, union) és void típusból áll. Az aritmetikai egyszerű, a származtatott összetett típus. Az aritmetikai típussal aritmetikai műveletek végezhetőek, még a származtatott elemeit belső kódok adják. A C az int 0-át hamisként ismeri, a többi számot (int 1 pl) igazként, ilyen a logikai felépítése, mert külön logikai típusa nincs. A karakter és egész típus előtt szerepelhet unsigned típusminősítő, ami előjel nélkülit jelent, illetve lehet signed, ami előjeles ábrázolást jelent. A struktúra fix szerkezetű rekord, míg a void típus tartománya üres, tehát nincsenek műveletei. A felsorolásos típus tartományai nem egyezhetnek meg, és elemei int típusú konstansok. Értékük egész literálokkal beállíthatóak, ha pedig ez nem történik meg explicit értékadással, 0-ról elindul az értékük, és eggyel nő az értékük a felsorolás sorrendjében haladva. A C nyelv csak egydimenziós tömböket kezel. A szabványok változásával folyamatosan történtek módosítások, pl C89, C99. A C a tömböt mindig mutató típusként kezeli, és ismeri az automatikusdeklarációt. A C nyelvben tudunk saját típust definiálni, struktúrát deklarálni és uniont is deklarálhatunk.
	</para>
	<para>
A C nyelvben a kifejezések szintaktikai eszközök, valamint értékük és típusuk van. Egy kifejezés 3 összetevőből állhat: az első az operandus, amely értékét ad vissza, a második az operátorok, amelyek a műveleti jelek és a harmadik a kerek zárójelek, amelyekkel pedig a végrehajtás sorrendjét tudjuk befolyásolni. Az operátorok egy-, két- vagy háromoperandusúak lehetnek. Az operátor és az operandus sorrendje lehet prefix, infix vagy postfix. Amikor kiértékelünk, akkor először végrehajtjuk a műveleteket, megkapjuk az értéket és egy típust rendelünk hozzá. Többféle sorrendet tudunk megkülönböztetni, a könyv szerint 3-at. Az operandusok meghatározásának sorbarendezésére a C nyelv azt mondja, hogy tetszőleges, azaz implementációfüggő. A zárójelezésre ügyelni kell. A logikai operátort tartalmazó kifejezések speciális kiértékelésűek. Ennek a meghatározásánál a nyelvek 2 elv közül választanak: típusegyenértékűséget vagy típuskényszerítést. A C nyelv néhány numerikus típusnál megenged bizonyos típuskényszerítést, ilyenkor beszélünk bővítésről vagy szűkítésről.
	</para>
	<para>
A konstans kifejezések kiértékelését a fordító végzi el, az értéke még a fordítási időbden eldől. A C egy kifejezésorientált nyelv, és a típuskényszerítést használja többnyire. A mutató típus elemeivel összeadást és kivonást tudunk végrehajtani. A C nyelvben használhatunk rekurzív függvényeket. Valamint a könyvben le van írva a C precedencia táblázata, amit ide nem másolnék át, (könyv 51.oldal). A következő 3 oldalon az operátorok értelmezéséről olvashatunk. Pl: a [] zárójel a tömboperátor, vagy a % jel a maradékképzés operátora.
	</para>
	<para>
Az utasításokról a Kernighan and Ritchie könyvben részletesen írtam, ezért itt csak a hiányzó részeket írnám, mivel csak a C nyelvről van szó, más nyelvekről nem. Az előírt lépésszámú ciklusokban megadunk kezdőértékét és végértéket is a fejben, valamint állíthatjuk a lépésközt is. A változó iránya változhat, tehát csökkenhet vagy növekedhet, attól függően, hogy merre járja be a tartományt. A felsorolásos ciklusban a ciklusváltozó több értéket is felvehet, ebben az esetben pedig a mag minden egyes értéknél lefut. A változót és az értékeket a ciklusfejben adjuk meg, még az értékeket kifejezésekkel adjuk meg. Létezik összetett ciklus, amely a többi ciklusfajta kombinációjából épül fel, és nagyon bonyolultra is lehet készíteni. 
	</para>
	<para>
Az eljárásorientált nyelvekben a program szövege programegységekre bontható. Léteznek olyan nyelvek, ahol az egységek külön-külön is fordíthatóak, néhányban csak egy egységként lehetséges ez, és van egy harmadik lehetőség ami ennek a kettőnek a kombinációja. Ezekben az eljárásorientált nyelvekben 4 féle programegység létezik: alprogram, blokk, csomag és taszk. Az alprogram a procedurális  absztrakció első megjelenési formája, de programozási eszközként is funkcionálhat, az újrafelhasználás eszköze. Az alprogramot elég egyszer megírni, újra felhasználható, csak hivatkozni kell rá, bizonyos helyeken meghívható. A formális felépítése: fej, törzs, vég; és 4 komponensből áll: név, formális paraméterlista, törzs és környezet. A formális paraméterlistát kerek zárójelek között találjuk meg. A törzsben a deklarációkat, azok utasításait és a végrehajtó utasítsoksat jelenítjük meg.  Az alprogramban létrehozott/deklarált programozási eszközötket lokális eszközöknek nevezzük, és ezek az alprogram lokális nevei. A környezetben a globális változók helyezkednek el. Az alprogram két fajtája az eljárás és a függvény. Az eljárás tevékenységet hajt végre, még a függvény célja, hogy egyetlen értéket adjon vissza. A függvény paramétert vagy környezetet módosít, akkor azt mellékhatásnak nevezzük, amit többnyire károsnak gondolunk. Az eljáráshívás elhelyezésének annyi kikötése van, hogy olyan helyen kell elhelyeznünk, ahol utasítás is szerepelhet. Az eljárás vagy külön utasításra fejeződik be, vagy akkor ha paranccsal megszakítjuk. Illetve néhány nyelv megengedi a GOTO-val történő megszakítást, és átugorva más címre folytatja a futást. Egy függvény többféleképpen meghatározhatja a visszatérési értéket, C-ben a leggyakoribb az, amikor külön utasítás szolgál a visszatérési érték meghatározására, ami ekkor a függvényt befejezi. Befejezzük a függvényt szabályosan, ha elérjük a végét és van visszatérési érték, vagy befejező utasítás és van már visszatérési érték/az utasítás ad vissza visszatérési értéket. Ha nincs visszatérési érték vagy GOTO utasítást használunk, az nem szabályos. Az utóbbi utasítás bizonyos körülmények között C-ben nem jelent gondot. Ezekben a(z eljárásorientált) nyelvekben lennie kell főprogramnak, ami elengedhetetlen. A betöltő a főprogramnak adja át a vezérlést és a többi programrész működéséért is ez felel. Ha ez befejeződik visszatérünk az operációs rendszerhez.
	</para>
	<para>
A blokk programegység, ami egy másik programegységen belül található, de nem lehet kívül. Kezdete (ami speciális karaktersorozat vagy alapszó), törzse (ahol a deklarációs és végrehajtó utasítások vannak) és vége van. A blokkoknak nincs paramétere, és bárhol elhelyezhetőek, ahol utasítás is szerepelhetne. GOTO utasítással be- és kiléphetünk belőle.
	</para>
	<para>
Néhány program megengedi, hogy az alapprogram meghívása a törzsben is megtörténhessen, ezeknek a kialakításához szükségesek a másodlagos belépési pontok, és annak a nevével lehet az alprogramra hivatkozni. Függvények esetében a típusnak egyeznie kell, és a másodlagos belépési pontnál a törzsnek csak egy része hajtódik végre.
A paraméterkiértékelés során az alprogram hívásakor egymáshoz rendelődnek a paraméterek, és meghatározzák a paraméterátadásnál a kommunikációhoz szükséges információkat. A paraméterkiértékelésben a formális paraméter aktuális paraméterhez történő hozzárendelése kétféleképpen következhet be: sorrendi kötéssel vagy név szerinti kötéssel. Ha a formális paraméterek száma fix, akkor az aktuálisnak azonos számúnak, vagy kevesebbnek kell lennie. Ha a formálisok száma tetszőleges, akkor az aktuálisoké is.
A paraméterátadás az alprogram és a programegységek közötti kommunikáció, ahol mindig van egy hívó és egy hívott. Az átadási módok érték (az érték meglesz a paraméterkiértékelés során, és átadódik a hívott alprogram címkomponensére), cím (a meghívott alprogram a hívó területén dolgozik, és az infirmációátadás kétirányú), eredmény (saját területén dolgozik, futás közben nem használja az aktuális paraméter címét, viszont ha végzett, átmásolja a formális paraméter értékét erre a címkomponensre), érték-eredmény (az aktuális paraméternek kell cím és értékkomponens, ha végez átmásolódik a formális paraméter értéke az aktuális címére, a kommunikáció kétirányú és kétszer másol), név (az aktuális paraméter egy tetszőleges szimbólumsorozat, ami a formális paraméter minden előfordulását felülírja az alprogram szövegében, és utána fut) és szöveg (a név szerintihez képest annyi a különbség, hogy hívás után elkezd futni, és akkor ír felül, ha először fordul elő a szövegben a formális paraméter) szerinti lehet. A C csak egyetlen paraméterátadási módot ismer. Az alprogramok formális paramétereit 3 csoportra tudjuk bontani, az információ mozgási iránya szerint.
	</para>
	<para>
A hatáskör, vagyis a láthatóág a program szövegének azon része, ahol a név ugyan azt a (programozási) eszközt hivatkozza. A név hatásköre az eljárásorientált nyelvekben a program- és fordítási egységekhez kapcsolódik. A lokális név a programegységben van, ami pedig azon kívül deklarálunk, de behivatkozzuk, az a szabad név. Dinamikus és statikus határkörkezelést ismerünk. A statikus a fordítási időben történik, és a fordító program készíti el. Ilyenkor a lokális név hatásköre a programegység. A hatáskör csak befelé terjed.A név ami a programegységben nem lokális, de onnan látható, az a globális név. A dinamikus hatáskörkezelésnél a név hatásköre a programegység, az az abból kiinduló hívási láncok. A dinamikusnál a hatáskör futási időben futásonként változhat. Az eljárásorientált nyelvek statikus hatáskörkezelést használnak.
	</para>
	<para>
Az programnyelvek közötti legnagyobb különbséget az input és output területe jelenti. A nyelvek különbözőképpen kezelik, néhányban nincs is erre meghatározott eszköz, hanem implementációfüggő. Az I/O feladata a perifériákkal történő kommunikáció, adatok küldése és fogadása és a középpontja az állomány. A logikai állományoknak neve és állományjellemzői vannak, a fizikai állomány pedig a perifériákon jelenik meg és adatokat foglal magába. Ha funkció szerint vizsgáljuk, akkor 3 féle állományt tudunk megkülönböztetni. Az első az input, ami már létezik a feldolgozás előtt, nem módosul közben, és csak olvasni tudjuk. A második az output, amely a feldolgozás során keletkezik, és írni lehet bele. Az utolsó pedig az input-output, ami már létezik a feldolgozás előtt és után is, de módosul, valaint írni és olvasni egyaránt lehet benne. Az I/O során adatmozgás történik, az adatok a periféria és a tár között mozog. A könyv 2 féle adatátviteli módról ír, az egyik a folyamatos és bináris, a másik pedig a rekord módú. Az első esetben az adatátvitel fogalma alatt az egyedi adatok átvitelét értjük konverzióval. A karaktersorozatot határozza meg ezzel, illetve annak akezelését, írását és olvasását. Ahhoz, hogy ezeket meg tudjuk adni, 3 különböző eszközrendszer alakult ki: a formátumos módú adatátvitel (a karakterek kezeléséhez szükséges a darabszám és a típus megadása), a szerkesztett módú adatátvitel (egy maszk kell az egyedi adatok átviteléhez) és a listázott módú átvitel (a karaktersorozatban már szerepelnek azok a speciális karakterek, amelyek a tördelésért felelősek). Bináris átvitel esetén a periféria és a tár ugyan úgy jeleníti meg a adatokat, de ekkor csak a háttértárral történő kommunikációról beszélhetünk. Amennyiben állományokat akarunk használni a programunkban, akkor néhány "feladatot" el kell végezni: deklaráció (név és attribútumadás), összerendelés (a logikai állománynak megg kell feleltetni egy fizikai állományt, ami többnyire a programban, nyelvi eszközök segítségével történik meg), az állomány megnyitása (ahhoz, hogy dolgozhassunk egy állománnyal, előbb meg kell nyitnunk, ez az operációs rendszer rutinjaival történik meg, amely valójában ellenőrzi, hogy a logikai állomány attribútumai és a fizikai jellemzői megfelelnek e), feldolgozás (megnyitás után írhatunk és olvashatunk is a megadott szabályok szerint) és a lezárás (elengedhetetlen folyamat, amelyet szintén az operációs rendszer rutinjaival végeznek, ekkor aktualizálódnak, vagyis frissülnek a könyvtárak adatai, információi, lezáráskor szűnik meg a kapcsolat a logikai és a fizikai állomány között, valamint a szabály szerint az output és input-output állományokat muszáj lezárni, az inputot pedig illik). A programozási nyelvek mára már megengedik nekünk, hogy az írás-olvasás során ne állományokban gondolkozzunk, hanem elképzelhetjük olyannak, mintha közvetlenül kerülne a perifériára. Ezt nevezzük implicit állománynak, tehát a fizikai és logikai állomány kap standard neveket és jellemzőket, így megoldható az automatikus kezelés. A C nyelvben nincs I/O eszközrendszer, vagyis nem része annak, helyette könyvtári függvényeket használhatunk.
	</para>
	<para>
A kivételkezelést a programozó az operációs rendszertől veszi át, valamint ezek megszakítást okoznak és maga a program végzi el. A nyelvek használnak bizonyos beépített kivételkezelőket, de megtörténhet, hogy megszakításkor a program nem veszi figyelembe és fut tovább, de ennek következményei lehetnek, amik csak utólag derülnek ki. A kivételeknek 2 fő tulajdonsága van, a név és a kód. Kivételt tud létrehozni a programozó is, ha condition(név) formában deklarálja azt. A kivételkezelés (Ada-ban) egy adott időpontban kezdődik, és a kezelés valamilyen formában történő lezárásáig tart. A PL/I hatáskörkezelése ellentmondásba ütközhet a nevek (statikus) és a kivételkezelő (dinamikus) kezelése miatt.
	</para>

    </section>        
    <section>
        <title>Programozás bevezetés</title>
        <para>                
            <citation>KERNIGHANRITCHIE</citation>
        </para>
 <para>
            Online könyv forrás: <link xlink:href="http://lidi.uw.hu/krc/index.html">http://lidi.uw.hu/krc/index.html</link>
        </para>                    
	<para>
Ebben az olvasónaplóban a változókkal és az adattípusokkal szeretnék kezdeni. Különböző változó típusokat, azaz adattípusokat tudunk megkülönböztetni, amelyek meghatározzák az adott változó formáját, ezzel befolyásolva a program működését. Az int, teljes nevén az intiger típusban a változó egész szám értéket vehet fel, ellentétben a float típussal, amely lebegőpontos értéket tartalmaz, tehát lehet tört szám. A változók nagysága függ a számítógép típusától is, de a leggyakoribb 16 bites int típus -32768 és +32767 között van. Létezik 32 bites int és float is. További adattípusokat, változó típusokat is ismer a C nyelv, ezek a char, ami karaktert jelöl egy bájton ábrázolva, a short rövid egész típust jelöl, a long hosszú egész típus, valamint a double típust ismerjük még, amely kétszeres pontosságú (2 tizedes jegy) lebegőpontos valós szám ábrázolására képes. A bithosszok módosíthatóak a short és a long előjellel. Például az int esetében, a short legalább 16, még a long legalább 32 bites. A short nem lehett hosszabb sem az inttől, sem a longtól. Hasonló elven működik a signed és az unsigned minősítők is, amelyeket a char vagy bármely egész típusnál használunk. Számok esetén az unsigned a típus előtt azt jelenti, hogy előjel nélküli, tehát a szám nagyobb vagy egyenlő, mint 0. A változók érvényességi tartománya változó. Léteznek lokális változók, amelyek pl csak egy adott függvényen belül léteznek, és ha lezártuk a függvényt, használhatjuk újra ugyan azt a változó nevet. A másik típus a globális változó, amely az egész programkódon átível, tehát nem használhatjuk ugyan azt a változónevet többször. Léteznek konstans változók is. Ezeknek is adunk egy nevet, de az értékük fix marad, nem változnak meg a programon belül sehol sem. Kiterjedésük globális vagy lokális.
	</para>
	<para>
A vezérlési szerkezetek című fejezetben néhány utasításról olvashatunk. A vezérlési szerkezeteka végrehajtási sorrendet határozzák meg. Egy kifejezés, akkor válik utasítássá, ha utána írjuk a ; jelet. Ezzel zárjuk le az utasítást, pl: printf(...); . A {} jelek közötti utasítások és deklarációk egyetlen utasítással érnek fel, és blokknak nevezzük. Ide több utasítást is írhatunk, amelyeket a program egyként kezel. A záró } jel után soha nem rakunk ; jelet. A blokkokban lehetdeklarálni is. Ilyen blokkok vannak pl az if, else, while vagy for, de saját függvények esetében is így működik. Ha döntéseket szeretnénk kifejezni, akkor az if-else utasításpárt használhatjuk. Az if után írjuk a kifejezést amit vizsgálni szeretnénk, és utána az utasítást, majd az else után a második utasítást. Az else rész opcionális. Ha az if-ben szereplő feltétel értéke igaz, akkor az első utasítás hajtódik végre, ha az hamis, akkor a program tovább ugrik az else ágra és a 2. utasítást hajtja végre. Amennyiben több if-et írtunk a programba, és van else ág, akkor az egyértelműség végett {} zárójeleket kell használnunk az if után, így biztosan tudni fogja a program, hogy mit tartalmaz az első utasítás. Az else-if utasítás szerkezet adja a többágú, vagyis a többszörös döntésú programozás legáltalánosabb lehetőségét. Itt az if, és az else if utasítások mögött is van egy kifejezés, amit megvizsgál. Amennyiben talál egy olyan kifejezést, ami igaz/teljesül, akkor végrehajtja azt és kilép az utasításból. A {} zárójelek közötti blokkok itt is ugyan úgy léteznek, mint az if-else esetben. A végén van egy if nélküli else ág is, ami akkor lép működésbe, ha a fenti feltételekből egy sem teljesül. Ez továbbra is csak opcionális. A switch utasítás szintén a többirányú programelágaztatás eszköze. A switch-ben megadjuk a kifejezést, amit meg kell vizsgálni, utána a case-ben pedig egy állandó kifejezést, amivel össze lehet hasonlítani a switch-ben szereplő értéket. Létrehozhatunk egy default ágat is, ami opcionális. Ez abban az esetben hajtódik végre, amennyiben a case kifejezései/értékei közül egyikkel sem egyezik meg a switch kifejezésével. A break utasítás feladata az, hogy megszakítsa az adott folyamatot. Ez az utasítás while, for vagy do utasításokból összeállított ciklusokból való kilépésre alkalmazható. A while és for ciklusokban a program először kiértékeli a kifejezést, és utána végrehajtja azokat, amennyiben az érték nem nulla. Ha 0 lesz az érték, az azt jelenti, hogy a kifejezés hamis, és megáll a program. A 3 kifejezés amit használunk a ciklusokban kihagyhatóak. Ha nincs kifejezés, akkor a program mindig igaznak tekinti, tehát végtelen ciklustkapunk. A break és return parancsokkal megállíthatóak. Ezekben a ciklusokban közös, hogy a ciklus tetején/fejben, tehát a ciklusmagba lépés előtt vizsgál. A do-while ezzel ellentétben legalább 1-szer végrehajtódik, és majd csak utána vizsgál. A do után leírjuk az utasítást, majd while(kifejezés), amit utána megvizsgál. Amennyiben igaz, újra lefut, ha hamis, akkor megáll és átlép a következő utasításra. Tehát a leállás feltételét a ciklusmag végrehajtása után ellenőrzi. A tapasztalatok szerint sokkal ritkábban használják a do-while ciklust, mint a for vagy while ciklust. Kényelmes a használata, {} zárójeleket nem kell használni, mivel a while rész nem téveszthető össze, egyértelműek a részek. A break utasítás kényelmi célt szolgál, így ellenőrzés nélkül is kiléphetünk a ciklusokból, valamint a switch utasításból. Utóbbinál vagy a belső utasítás vagy a teljes switch fejeződik be. A continue utasítást csak ritkán használják. Hatására a kifejezést figyelmen kívül hagyva végbemegy az utasítás/megkezdődik a következő iterációs lépés. Akkor használjuk, ha a ciklus további része nagyon bonyolult. A goto utasítás vitatott múltú. Ezzel az utasítással a megadott címkékre lehet ugrani. Ritkán használják, könnyen lehet olyan programot írni amiben nincs rá szükség. Gyakorlati haszna, amikor egymásba ágyazott szerkezetek belsejében szeretnénk félbe hagyni a feldolgozást. Ilyenkor a break utasítás nem használható, hiszen az csak a legbelső utasításból/ciklusból lép ki. A goto utasítást érdemes a lehető legritkábban használni, mert azok a programok, amiben szerepel, többnyire nehezebben átláthatóak.
	</para>
	<para>
Az utasítások amennyiben nem jelezzük külön, a leírásuk sorrendjében hajtódik végre. Az utasítások nem rendelkeznek értékkel, hanem "hatással vannak" a programra. Több csoportjukat ismerjük. Az első amiről írnék, azok a címkézett utasítások. Ezekhez az utasításokhoz előtagként megadott címkék tartozhatnak. A címkék csak goto utasítás célpontjául használható. Nem tartozik hozzájuk tárterület, és az aktuális függvényeken belül érvényesek csak. A kifejezésutasítások közül a legtöbb függvényhívás vagy értékadás. Ha hiányzik belőle az utasítás, null-utasításnak nevezzük. Utasítások üres ciklusmagjának vagy címkék helyének jelölésére használhatják. Összetett utasításokat olyan helyeken használunk, ahol a fordítóprogram csak egyetlen utasítással dolgozik, csak annyit fogad el. A blokk ezt a célt teljesíti. Ilyen lehet például egy függvénydefiníció. A blokkon kívüli deklarációk nem érvényesek a blokkon belül, addig megszűnnek. A kiválasztó utasítások egy lehetséges végrehajtási sorrendet választanak ki. If, if-else vagy switch használatával lehetségesek. A switch utasítás összetett utasítás, de ezeknek a működését korábban kifejtettem a könyv alapján, ugyan ez a működési elv itt is. Az iterációs utasítások ciklusok felhasználásával keletkeznek, tehát while, do-while és for ciklussal. Itt szintén a ciklusok működését kellene kifejteni, de korábban ez már szerepel. Az utolsó csoport a vezérlés nélküli utasítások, amelyek a vezérlés feltétel nélküli átadására képesek. Ezek az utasítások a goto, continue, break és return. A return kivételével a többit kifejtettem korábban. A függvények a hívások hatására a return hívó függvény hatására térnek vissza. Utána kifejezés áll, amelyet a hívó függvénynek ad vissza. Ha nincs return, akkor nincs definiálva visszatérési érték. 
	</para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/zmfT9miB-jY">https://youtu.be/zmfT9miB-jY</link>
        </para>        
    </section>        
    <section>
        <title>Programozás</title>
        <para>                
            <citation>BMECPP</citation>
        </para>
	<para>
A C++ alkalmas objektumorientált és generikus programozásra is, azonban alacsony nyelvi szintű programnyelveket is támogat. Bjarne Stroustrup a "kitaláló atyja". A C nyelvre épül, és azt terjeszti ki. A különböző fordító programok segítségével a C programok működnek C++-ban is.
	</para>
	<para>
Különbségek a C és C++ között. Az utóbbi nyelven az üres paraméterlista a void függvény megadásával azonos, amelyek jelentése az, hogy a függvényeknek nincs paramétere. Ugyanakkor C++-ban is van lehetőség számunkra szabadon választható számú paraméterrel hívható függvények meghatározására. Ezek a nyelvek a függvény visszatérési típusának meg nem adásától függően különböző módon viselkednek. A C++-ban a main függvényt kétféleképpen határozhatjuk meg. A return használata nem kötelező a főfüggvényben, ebben az esetben automatikusan return 0-ként kezeli, azaz sikeres futásként. Újdonság a bool típus is, amely egy logikai típus, és true vagy false, tehát igaz-hamis értéket képes felvenni. Ennek a típusnak az előnye, hogy olvashatóbb kódokat eredményez. Létezik automatikus konvenzió a túlterhelés ellen, a 0 int értéket a nyelv falsenak, még minden más értéket truenak vesz. Ezek a szavak a C++ kulcsszavai közé tartoznak. A C++--ban már könnyebben használhatóak a Unicode karakterek mint a C-ben, mert itt már előre definiálták őket. A változódeklarálás is másabb a C++--ban. Itt minden olyan helyen lehet változódeklaráció, ahol utasítás állhat. Ott érdemes deklarációt létrehoznunk, ahol azt használni szeretnék használni (vagyis előtte), így csökkenthetjük a hibalehetőséget és átláthatóbbak a kódok. A változók érvényessége a deklarációtól kezdődik, és a blokk végéig tart (kivéve if, for). Míg a C nyelven nem lehetett 2 azonos nevű függvény, addig a C++-ban lehet, ahol a nevekhez az argumentumaikat társítják, és azzal különböztetik meg. Ha C++-ban akarunk C-ként fordítani, akkor az extern "C" deklarációt kell a függvény deklarációja elé írni. A C++ a névelferdítés technikáját használja. A C++-ban lehetőségünk van arra, hogy a függvényargumentumoknak kezdeti értéket adjunk, amennyiben ez nem történik meg, akkor alapértelmezett értéket kap. Az alapértelmezett argumentumok megadásának többnyire a függvénydeklarációnál van értelme a használat miatt. A C programok csak az érték szerinti paraméterátadást ismerik. A paraméter átadásának érdekében mechanikus átalakítást kell végeznünk. A paraméterlistában a változó helyett pointert veszünk át, tehát a név elé írunk egy *-ot. A változó helyett annak a címét kell átadni, ezért az átadandó változó neve elé írunk egy "end/és" jelet. Így az átadott érték maga a pointer lesz, tehát könnyebb lesz a módosítás. Ezt cím szerinti paraméterátadásnak nevezzük. Az érték szerintivel ellentétben, itt már végezhetünk módosításokat, míg az utóbbi másolatot készít, de nincs hatással az eredeti változóra. A C++-ban bevdezették újabb könnyítésként a referenciatípust, ezzel feleslegessé téve a pointer szerepét a referenciaátadásban. Az "end" jel a C-ben operátorkét funkcionált, és ezt tovább hozta magával, és ezt a C++ fel tudja használni referencia deklarálásához. Csak megváltoztatható kifejezést kaphat a referencia, pl nem lehet konstans, kivéve konstansreferencia. Lokális változókra nem szabad referenciával hivatkozni, mert ezek felszabadulnak, így üres memóriaterületre hivatkoznának.
	</para>
	<para>
Az objektumorientáltság alapelveinél az áttekinthetőség szerepe kulcsfontosságúra nőtt. Az egységbe zárás az egyik alapelv, ami az adatstruktúra tulajdonságait és a rajta végzett műveleteket tartalmazza. Az egységbe záró struktúra neve osztály, ami egyfajta kategóriaként funkcionál. A példányokat, vagyis önálló "egyedket" objektumoknak nevezzük. Ha a program többi része hozzáfér egy bizonyos tulajdonséghoz, akkor azon változtatni is tud. Ezért kell adatvédelmet biztosítanunk, hogy az objektum "tudjon vigyázni önmagára", és a program belsejéhez ne férjen hozzá a program többi része, ezért ezt az egyfajta védekezést hívjuk adatrejtésnek. A könyv példája a személy-alkalmazott viszony, amivel a tulajdonságok öröklését mutatja be. Egy másik tulajdonság a behelyettesítés, vagyis az alkalmazottat kezelhetjük személyként is, tehát egy speciális osztály objektuma bárhol felhasználható, a speciális helyettesíti az általánost. Ez az OO = objektumorientált programozás 3 alapelve. A típustámogatás már nem tartozik ezek közé, de a felhasználásakor a felhasználó által definiált típusként úgy viselkedik mint a beépített típusok. Az OO programozásban ha analízisről vagy tervezésről beszélünk, akkor objektumokban és osztályokban gondolkodunk, ami jobban tükrözi az emberi gondolkodásmódot. Az OO miatt teljesítménycsökkenés tapasztalható, ezért lényeges az átláthatóbbá tétel. Az előnye viszont, hogy összetettebb problémákat is meg lehet oldani. Az egységbe zárásra példa a koordináta rendszer. Mivel egy ponthoz az x és y koordináta összetartozik, ezért egy struktúrába lehet őket zárni. A függvények ugyan úgy szorosan kapcsolódnak a koordinátákhoz, mint azok egymáshoz, tehát érdemes a függvényeket a struktúra tagfüggvényeivé tenni. A tagváltozót nevezzük attribútumnak, a tagfüggvény pedig metódus vagy művelet más néven. Tehát a tagváltozó a struktúra adattagja. Ahányszor változót hozunk létre, annyiszor foglalódik hely a struktúra tagváltozóinak. A tagfüggvényeket osztálydefinícióban, és a struktúradefiníción kívül is megadhatjuk. A struktúradefiníción belül a prototípust adhatjuk meg. A hatókör operátor az ütközések elkerülésére szolgál. A tagfüggvény csak egyetlen példányban jön létre a memóriában. Az adatok és a függvények így a struktúrában egy helyre kerültek. Az adatrejtéssel a változó adattagjait az adatfüggvényből lehet így csak elérni, és kívülről nem. Erre van a private kulcsszó. Az ez után felsoroltak az az adott osztályon belül lesznek láthatóak. Ellentéte a public, ami osztályon kívülről is elérhető és módosítható. A struktúra nem tükrözi ezt az elvet ennyire szabályosan. Az osztály egy típus, amelyből ha fel szeretnénk használni, változót kell deklarálnunk. Ezt az osztály példányosításának nevezzük. A létrejött változó az objektum. Az osztálydefiníció többször is be lehet építve a forrásállományba, ide kell az #ifndef direktíva, vagyis ezt ilyenkor használjuk. A konstruktor az objektumok létrejötténél az inivializálásra lett kitalálva, hogy az objektum inicializálhassa önmagát. Ez egy speciális tagfüggvény és a neve megegyezik az osztályéval, aminek a példányosításakor automatikusan meghívódik. A konstruktor is túlterhelhető. Üres zárójelek nem megengedettek. Ha nem írunk konstruktort, akkor az osztály létrehoz egyet, ami alapértelmezett, de nem csinál semmit. Viszont ha mi írtunk, akkor az osztály csak azzal példányosítható. Az objektumok által birtokolt erőforrások felszabadítását a destruktor végzi el, és egy ~ jellel kezdődik, majd az osztály neve jön, ezzel felszabadítunk. A dinamikus memóriakezelés arra szolgál, hogy ha nem adtuk meg a tároló maximális méretét, akkor addig tehetünk bele elemeket, ameddig tud nekik memóriát foglalni. A C-hez képest már továbbfejlesztették a biztonságát. C++-ban a new operátorral lehet létrehozni, amire a paraméterátadás miatt van szükség, tehát ezért nem függvényre va szükség. A new a lefoglalt típusra mutató pointerrel tér vissza. Az üres zárójellel alapértelmezett konstruktort hívunk. Használat után a delete operátor segítségével szabadítunk fel. A delete meghívja a felszabadításra váró objektum destruktorát. A tömbök lefoglalása és felszabadítása new[] és delete[] operátorral történik. Ha ezeket nem tartjuk be, memóriaszivárgás, vagy más következménye is lehet. A FIFO dinamikus osztállyal a tároló egész típusú értékeit egy pointerrel megjelölt dinamikus foglalású adatterületen tároljuk el. Az új elemnél dinamikus területet növelünk, és hozzáfűzzük az adatot. Ha elveszünk egy elemet, akkor a területet csökkentjük és átmásoljuk a többi elemet. Óvatosnak kell lennünk, mert utána a memóriaterületet fel is kell szabadítani. A nyilvántartásra nem elég egy pointer, tudnunk kell az elemeink számát. A memóriaterület a beletett és kivett elemktől függően fog változni. Ha új elemet helyezünk kell, 2 dologra kell figyelnünk: meghaladja, vagy nem haladja meg a tároló mérete az előre foglalt területet. Az első esetben nagyobb méretű tömböt kell foglalnunk, áthelyezni a tartalmat, az új elemet hozzáfűzni, felszabadítani a tömböt és a pointert át kell irányítani. A másik esetben az elemet csak a végére fűzzük. A másolókonstruktor rendelkezik az összes többi konstruktor lehetőségeivel, azaz létrehozáskor az objektumot inicializálhatjuk. A másoló esetén a meglévő konstruktor alapján inicializáljuk, cél a másolat készítés. A másolás beépített típusoknál egyszerű, mert ismeri (méretét, helyét a memóriában, stb...), és így csak bitenként átmásolja. Ez a művelet struktúrára és objektumokra egyaránt elvégezhető. A másoláshoz függvényt kell írnunk, másképp bitenként másol. A bitenkénti másolást sekély másolásnak nevezzük, még a dinamikus másolást mély másolásnak. Ha nem írnánk másoló konstruktort, akkor a példában a main függvényben a fifo azt hinné, hogy minden a régi, de a param objektum függvényből való kilépéskor destruktor hívódik, ami felszabadítja a data által mutatott területet. Emiatt a fifo tartalmát használó lekérdező és módosító függvények, és a destruktor érvénytelen adatterülettel dolgozna. Ez az érték szerinti paraméterátadásnál vagy inicializálásnál probléma. Ha mégis így adnánk át, kiderülne a hiba. C++-ban az osztály adhat jogosultságot globális valamint más osztályok tagfüggvényeinek ahhoz, hogy hozzáférjenek a saját védett részeihez. Itt a friend függvény szolgál erre a célra. Attól még ugyan úgy globális függvény marad, csak speciális jogai vannak. A friend osztály hasonló ehhez, csak az egy másik osztályt jogosít fel arra, hogy hozzáférjen a védett tagjaihoz. A friend tulajdonság nem öröklődik, és nem tranzitív. Ez nem mond ellent az adatvédelemnek, mert szabályozott módon történik, de nem érdemes túl gyakran használni. Az inicializálás jelenthet konstruktorhívást, vagy az "=" jellel értékadást. A tagváltozókat a konstruktor inicializálási listában tudjuk inicializálni. Az argumentumok után ":" jelet teszünk, és utána írjuk az inicializálni kívánt tagváltozókat. A statikus tagokváltozók speciális változók, amelyek definiálásra van lehetőség. Ezek a változók közös értéket vesznek fel. Ha az osztálynak nincs objektuma, akkor is használhatóak. A deklarálásukhoz static kulcsszóra van szükség. Ezeket az osztálydefiníción kívül is definiálni kell. A szintaktika hasonlít a globális változókéhoz, de hatókör (::) operátor szükséges. Statikus tagfüggvények definiálására is van lehetőség. Ezek a statikus változókkal dolgoznak. A statikus tagfüggvényekből a nem statikus változók és tagfüggvények nem érhetőek el. A statikus függvényekben a this mutató nem használható/értelmezhető. A közös statikus változó itt a count. Az adatrejtés miatt private. Akkor célszerű a használata, ha az adott osztály minden objektumára közös változóra van szükség. Mindig az induláskor inicializálódnak. Az osztálydefiníción belül adhatunk meg enumeráció, osztály, struktúra vagy típusdefiníciót, ezt hívjuk beágyazott definíciónak. A beágyazott enumeráció definíció az objektum viselkedését befolyásolja. Más osztályok tagfüggvényeiből vagy globális függvényekből csak a minősített nevükkel érhetőek el a beágyazott típusdefiníciók. A beágyazás nélkül a globális megvalósítással a névütközések száma valószínűleg több lenne. Ha private szakaszba vannak beágyazva ezek a definíciók, akkor csak az osztályon belüli tagfüggvényekből lennének elérhetőek. A beágyazott definíciók használatával sem érdemes túlzásba esni.
	</para>
	<para>
Az operátorok az argumentumaikon hajtanak végre műveleteket, amelynek az eredményét visszatérési értekként történő feldolgozásával használhatjuk. Például: a c++ kifejezésben a c legyen a változó, a ++ operátor argumentuma. Az operátorok kiértékelése bizonyos sorrend, egy speciális szabályrendszer szerint történik meg. Érdemes zárójelekkel használni. Még a C-ben csak érték szerinti paraméterátadás volt, addig a C++--ban már nincs ez a korlátozottság. C++-ban az operator egy kulcsszó, amit speciális függvényekhez adunk meg. Az operátorok (pontosabban speciális függvények és függvénynevek) is túlterhelhetőek a függvényekhez hasonlóan. Az osztály típus miatt érdemes tagfüggvényként definiálni. Definiálhatunk ilyen operátorokat pl összeadáshoz, kivonáshoz, szorzáshoz... A könyvben van rá konkrét példa is.
	</para>
	<para>
Az I/O kezelés: A C nyelvben a program miután elindult, 3 létrehozott és megnyitott állományt és leíróját tudjuk felhasználni, pontosabban az stdin, stdout, és stderr, amelyek a szabályos bemenet, kimenet és hibakimenet. Ezek magas szintű állományleírók és FILE* típusúak, az stdin csak olvasható, még az stdout és stderr pedig csak írható. Ezzel ellentétben a C++-ban már objektumokban kell gondolkozni, mert ez adatfolyamatokban, vagyis streamekben gondolkozik, amelyek irányítására 2-2 egymás mellé írt jobbra vagy balra nyíló kacsacsőr szolgál. A könyvben találhatunk erről egy táblázatot, ami jól összefoglaljaaz előbb leírtakat. Ezeknek a használatához szikséges includolni az iostream állományt, valamint érdemes a következő sorba beírnunk, hogy using namespace std, mert így nem kell kiírnunk mindehová hogy std:: , azaz azt, hogy standard névteret használunk. Adatáramláskor a kacsacsőrök olyanok mint a nyilak, tehát az adatáramlás irányába mutatnak. A cin nagyon hasonlít a scanf-re, és addig halad ameddig meg nem kapta a megfelelő bemenetet, vagy el nem ért egy záró karaktert vagy a bemenet végét. C-ben volt az fflush(stdin) függvény, amely megakadályozta hogy megálljon a beolvasás. A rendszerhívások nagy költséggel járnak, ezért az adatfolyamok buffert kapnak, és a program egy rendszerhívással több cout kiírást is kezel, kiír, amennyiben viszont törölnénk a buffert, flush "kiíratással" megtehetjük, cout.flush(). A memória fogyás esetére, haezt közölni kellenemár a felhasználóval, a cerr nem rendelkezik bufferrel. C++-ban létezik egy iostate tagváltozó, amely az adatfolyam állapotának jelzésére szolgál, és 4 konstanssal állítható az értéke: eofbit, failbit, badbit, goodbit, és ezeket a clear tagfüggvénnyel lehet beállítani. Azt, hogy a beolvasás sikeres e, függvény helyett whileciklussal is megoldhatjuk. A könyv 79. oldalán található egy táblázat, amely leírja a beolvasás és kiíratás fontosabb tagfüggvényeit, és ugyan azokat C-ben is. C++-ban már van string osztály, így beolvasáskor az automatikusan növeli a saját méretét, azonban ha szóközt kap, ez a beolvasás is megállna, erre a megoldás pedig a getline függvény, amellyel sorokat és szóközt tartalmazó szöveg is beolvasható. Léteznek I/O manipulátorok, amelyek speciális objektumok és az adatfolyamot módosítják, valamint a megszokott ki- és bemeneti operátorok argumentumaként kell alkalmazni. Szükséges a használatukhoz az iomanip állományt includálni. Manipulátor például az endl, a noskipws, a ws vagy a setw. Néhány manipulátor rendelkezik paraméterrel, néhány pedig nem. Léteznek jelzőbitek, vagy más néven flags, illetve maszk, amely egy bináris szám, amit abban az esetben kapunk meg, ha egyszerre több tulajdonságot szeretnénk tárolni, és a tulajdonságot meghatározó bitek 1-esek. Állománykezelésnél C++-ban a leírót egy objektum zárja körbe, és ennek a tagfüggvényeinek a felhasználásával tudunk különböző műveleteket elvégezni. A leíró tagváltozóként érhető el. A C++ állománykezeléshez adatfolyamot használ, ehhez szükség van az ifstream és ofstream osztályokra, mivel ezekkel valósítja meg, illetve az fstream foglalja ezeket magába, mivel ez kétirányú áramlást biztosít. A korábban leírt, adatfolyamokon végzett műveletek itt is érvényesek, mivel ezek is lényegében adatfolyamok. A megnyitásáért konstruktorok, a lezárásáért pedig destruktorok felelősek, ígybiztonságosabb a folyamat. A használatához szükség van az std névtérre (tehát érdemes a using namespace std) és az fstream includálására. Az üzemmódok használatához jelzőbitekre van szükség, smelyeket ios:: előtaggal kell használni. A konstruktor és destruktor helyett használhatunk függvégenyeket, pontosabban az open és a close függvényeket, valamint létezik az is_open tagfüggvény, amellyel megvizsgálhatjuk, hogy meg van e nyitva az állomány. A pozícionlásra 2 függvényt tudunk felhasználni, bemeneti adatfolyam esetén olvasási pozícionálásról (get) beszélhetünk, kimenetinél pedig írásiról (put). A programozó felelőssége, hogy jól pozícionáljon, vagyis érvényes pozícióval dolgozzon. Használhatunk átirányítást is, amely jelen volt már C-ben is, de C++-ban már csak módosításokat végeztek rajta (megnyitjuk az állományt és az irányítandó adatfolyam tulajdonságait, majd átmásoljuk azokat a megnyitott adatfolyamunkba). 
	</para>
	<para>
A C-ben történő hibakezeléshez és kivételezéshez képest a C++ egy fejlettebb megoldást nyújt, mert amíg a C hibakódokkal dolgozott, addig a C++ a kivételezés segítségével felhasználóbarátabb és könnyebb a hibakezelése. A hiba- és kivételkezelés fogalma nem egy és ugyan az, mert kivételeket alkalmazhatunk bármikor, amikor szeretnénk, attól függetlenül, hogy helyes vagy hibás, ilyenkor a program a kivételkezeléshez lép. A 190.oldal példájának megoldása szerint egy try catch blokk alkalmas a vizsgálatra, ha a catch rész tartalmazza a hibakezelést. Amennyiben a try, vagyis a védett részben nem találkozunk semmilyen hibával, akkor fut tovább a program, és a catch következik, ami viszont csak akkor fut le, ha előtte hiba volt. Ha nem volt, akkor a catch lényegében kimarad, és folytatódik a futás a következő résszel. A throw utasítás a kivételkezelést szolgálja, és emiatt rögtön jön a catch ág, ahová a kivétel bekerül. Ezek után pedig kiíródik a catch utána rész, jelen esetben a "Done." szöveg. A továbbiakban a könyvben függvények kivételkezeléséről olvashatunk, és azokra láthatunk 1-1 példát. A try catch blokkokkal megtehetjük, hogy egymásba ágyazzuk őket, tehát szinteket hozunk létre, erre a 195. oldalon láthatunk példát. Illetve, ha a throw függvény másképp használjuk, vagyis pontosabban nem adunk meg neki paramétert, akkor elérhetjük vele, hogy a megfogott kivételt újradobja. A 197. oldal példája a verem visszacsévélését mutatja be, azaz a dobás és elkapás között léteznek olyan függvények, amelyeknek a lokális változói felszabadulnak. Egy dobás és elkapás között nem lehet újabb kivétel dobás, mert az összességében a program futásának leállásához fog vezetni. A 211. oldalon látható kódcsipet az erőforrás kezelésre mutat egy példát. Ez bemutatja, hogy a memóriát mikor kell felszabadítani, illetve az ez után történő kivétel újradobás kulcsfontosságú, hiszen amennyiben eltekintenének tőle, akkor a hiba nem derülne ki.
	</para>
    </section>        
</chapter>                

